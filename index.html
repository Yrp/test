<html>
<head>
  <meta charset="utf-8">
  <title>查看信息</title>
  <script type="text/javascript" src="base58.js"></script>
  <script type="text/javascript" src="code.js"></script>
  <script type="text/javascript" src="sha256.js"></script>

  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script type="text/javascript">
    var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    var ALPHABET_MAP = {}
    for (var i = 0; i < ALPHABET.length; i++) {
      ALPHABET_MAP[ALPHABET.charAt(i)] = i
    }
    var BASE = 58

    function encode58(buffer) {
      if (buffer.length === 0) {
        return ''
      }

      var i, j, digits = [0]
      for (i = 0; i < buffer.length; i++) {
        for (j = 0; j < digits.length; j++) {
          digits[j] <<= 8
        }

        digits[0] += buffer[i]

        var carry = 0
        for (j = 0; j < digits.length; ++j) {
          digits[j] += carry

          carry = (digits[j] / BASE) | 0
          digits[j] %= BASE
        }

        while (carry) {
          digits.push(carry % BASE)

          carry = (carry / BASE) | 0
        }
      }

      // deal with leading zeros
      for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) {
        digits.push(0)
      }

      return digits.reverse().map(function (digit) {
        return ALPHABET[digit]
      }).join('')
    }

    function decode58(string) {
      if (string.length === 0) {
        return []
      }

      var i, j, bytes = [0]
      for (i = 0; i < string.length; i++) {
        var c = string[i]
        if (!(c in ALPHABET_MAP)) {
          throw new Error('Non-base58 character')
        }

        for (j = 0; j < bytes.length; j++) {
          bytes[j] *= BASE
        }
        bytes[0] += ALPHABET_MAP[c]

        var carry = 0
        for (j = 0; j < bytes.length; ++j) {
          bytes[j] += carry

          carry = bytes[j] >> 8
          bytes[j] &= 0xff
        }

        while (carry) {
          bytes.push(carry & 0xff)

          carry >>= 8
        }
      }

      // deal with leading zeros
      for (i = 0; string[i] === '1' && i < string.length - 1; i++) {
        bytes.push(0)
      }

      return bytes.reverse()
    }

    function bin2String(array) {
      return String.fromCharCode.apply(String, array);
    }

    //比较两个byteArray是否相等
    function arrayEquals(array1, array2) {
      if (array1.length != array2.length) {
        return false;
      }
      var i;
      for (i = 0; i < array1.length; i++) {
        if (array1[i] != array2[i]) {
          return false;
        }
      }
      return true;
    }

    //从base64字符串中解析TransAction对象
    function getTransActionFromBase64String(base64String) {
      var bytesDecode = base64DecodeFromString(base64String);
      var transaction = proto.protocol.Transaction.deserializeBinary(bytesDecode);
      //ToDo : ret is success
      return transaction;
    }

    //Return a list contains contract object
    //从TransAction对象中获得合约列表
    function getContractListFromTransaction(transaction) {
      var raw = transaction.getRawData();
      var type = raw.getType();
      if (type != 1) {
        layer.alert("Invalid transaction type !!!!" + type);
        return null;
      }
      var contractList = raw.getContractList();
      var count = contractList.length;
      if (count == 0) {
        layer.alert("No contract !!!!");
        return null;
      }

      array = new Array(count);
      var unpack = proto.google.protobuf.Any.prototype.unpack;
      while (count > 0) {
        count--;
        var oneContract = contractList[count];
        var any = oneContract.getParameter();
        var contarcType = oneContract.getType();
        var obje;
        switch (contarcType) {
          case proto.protocol.Transaction.Contract.ContractType.ACCOUNTCREATECONTRACT:
            obje = any.unpack(
                proto.protocol.AccountCreateContract.deserializeBinary,
                "protocol.AccountCreateContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.TRANSFERCONTRACT:
            obje = any.unpack(
                proto.protocol.TransferContract.deserializeBinary,
                "protocol.TransferContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.TRANSFERASSETCONTRACT:
            obje = any.unpack(
                proto.protocol.TransferAsstContract.deserializeBinary,
                "protocol.TransferAssetContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.VOTEASSETCONTRACT:
            obje = any.unpack(
                proto.protocol.VoteAssetContract.deserializeBinary,
                "protocol.VoteAssetContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.VOTEWITNESSCONTRACT:
            obje = any.unpack(
                proto.protocol.VoteWitnessContract.deserializeBinary,
                "protocol.VoteWitnessContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.WITNESSCREATECONTRACT:
            obje = any.unpack(
                proto.protocol.WitnessCreateContract.deserializeBinary,
                "protocol.WitnessCreateContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.ASSETISSUECONTRACT:
            obje = any.unpack(
                proto.protocol.AssetIssueContract.deserializeBinary,
                "protocol.AssetIssueContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.DEPLOYCONTRACT:
            obje = any.unpack(
                proto.protocol.DeployContract.deserializeBinary,
                "protocol.DeployContract");
            break;

          case proto.protocol.Transaction.Contract.ContractType.WITNESSUPDATECONTRACT:
            obje = any.unpack(
                proto.protocol.WitnessUpdateContract.deserializeBinary,
                "protocol.WitnessUpdateContract");
            break;
        }
        array[count] = obje;
      }
      return array;
    }

    //字符串转byteArray数据格式
    function stringToBytes(str) {
      var bytes = new Array();
      var len, c;
      len = str.length;
      for (var i = 0; i < len; i++) {
        c = str.charCodeAt(i);
        if (c >= 0x010000 && c <= 0x10FFFF) {
          bytes.push(((c >> 18) & 0x07) | 0xF0);
          bytes.push(((c >> 12) & 0x3F) | 0x80);
          bytes.push(((c >> 6) & 0x3F) | 0x80);
          bytes.push((c & 0x3F) | 0x80);
        } else if (c >= 0x000800 && c <= 0x00FFFF) {
          bytes.push(((c >> 12) & 0x0F) | 0xE0);
          bytes.push(((c >> 6) & 0x3F) | 0x80);
          bytes.push((c & 0x3F) | 0x80);
        } else if (c >= 0x000080 && c <= 0x0007FF) {
          bytes.push(((c >> 6) & 0x1F) | 0xC0);
          bytes.push((c & 0x3F) | 0x80);
        } else {
          bytes.push(c & 0xFF);
        }
      }
      return bytes;

    }

    //byteArray数据格式转字符串
    function bytesToString(arr) {
      if (typeof arr === 'string') {
        return arr;
      }
      var str = '',
          _arr = arr;
      for (var i = 0; i < _arr.length; i++) {
        var one = _arr[i].toString(2),
            v = one.match(/^1+?(?=0)/);
        if (v && one.length == 8) {
          var bytesLength = v[0].length;
          var store = _arr[i].toString(2).slice(7 - bytesLength);
          for (var st = 1; st < bytesLength; st++) {
            store += _arr[st + i].toString(2).slice(2);
          }
          str += String.fromCharCode(parseInt(store, 2));
          i += bytesLength - 1;
        } else {
          str += String.fromCharCode(_arr[i]);
        }
      }
      return str;
    }

    function hextoString(hex) {
      var arr = hex.split("")
      var out = ""
      for (var i = 0; i < arr.length / 2; i++) {
        var tmp = "0x" + arr[i * 2] + arr[i * 2 + 1]
        var charValue = String.fromCharCode(tmp);
        out += charValue
      }
      return out
    }

    /* Convert a hex char to value */
    function hexChar2byte(c) {
      var d = 0;
      if (c >= 'A' && c <= 'F') {
        d = c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      }
      else if (c >= 'a' && c <= 'f') {
        d = c.charCodeAt(0) - 'a'.charCodeAt(0) + 10;
      }
      else if (c >= '0' && c <= '9') {
        d = c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      return d;
    }

    /* Check if a char is hex char */
    function isHexChar(c) {
      if ((c >= 'A' && c <= 'F') ||
          (c >= 'a' && c <= 'f') ||
          (c >= '0' && c <= '9')) {
        return 1;
      }
      return 0;
    }

    /* Convert HEX string to byte array */

    //16进制的ASCII字符串转为byteArray格式。
    function hexStr2byteArray(str) {
      var byteArray = Array();
      var d = 0;
      var i = 0;
      var j = 0;
      var k = 0;

      for (i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (isHexChar(c)) {
          d <<= 4;
          d += hexChar2byte(c);
          j++;
          if (0 == (j % 2)) {
            byteArray[k++] = d;
            d = 0;
          }
        }
      }
      return byteArray;
    }

    /* Convert a byte to string */
    function byte2hexStr(byte) {
      var hexByteMap = "0123456789ABCDEF";
      var str = "";
      str += hexByteMap.charAt(byte >> 4);
      str += hexByteMap.charAt(byte & 0x0f);
      return str;
    }

    /* Convert byte arry to HEX string */

    //byteArray格式数据转为16进制的ASCII字符串。
    function byteArray2hexStr(byteArray) {
      var str = "";
      for (var i = 0; i < (byteArray.length - 1); i++) {
        str += byte2hexStr(byteArray[i]);
      }
      str += byte2hexStr(byteArray[i]);
      return str;
    }

    //从base64字符串中解码出原文，格式为byteArray格式
    function base64DecodeFromString(string64) {
      var b = new Base64();
      var decodeBytes = b.decodeToByteArray(string64);
//  var decodeBytes = stringToBytes(decodeString);
      return decodeBytes;
    }

    //return baset64 String
    //将byteArray格式数据编码为base64字符串
    function base64EncodeToString(bytes) {
      // var string = bytesToString(bytes);
      var b = new Base64();
      var string64 = b.encodeIgnoreUtf8(bytes);
      return string64
    }

    function Base64() {

      // private property
      _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

      // public method for encoding
      this.encode = function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
//    input = _utf8_encode(input);
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output = output +
              _keyStr.charAt(enc1) + _keyStr.charAt(enc2) +
              _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output;
      }

      // public method for encoding
      this.encodeIgnoreUtf8 = function (inputBytes) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
//    input = _utf8_encode(input);
        while (i < inputBytes.length) {
          chr1 = inputBytes[i++];
          chr2 = inputBytes[i++];
          chr3 = inputBytes[i++];
          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output = output +
              _keyStr.charAt(enc1) + _keyStr.charAt(enc2) +
              _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output;
      }

      // public method for decoding
      this.decode = function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
          }
        }
        output = _utf8_decode(output);
        return output;
      }

      // public method for decoding
      this.decodeToByteArray = function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
          }
        }
        var outBytes = _out2ByteArray(output);
        return outBytes;
      }

      // private method for UTF-8 decoding
      _out2ByteArray = function (utftext) {
        var byteArray = new Array(utftext.length)
        var i = 0;
        var c = c1 = c2 = 0;
        while (i < utftext.length) {
          c = utftext.charCodeAt(i);
          byteArray[i] = c;
          i++;
        }
        return byteArray;
      }

      // private method for UTF-8 encoding
      _utf8_encode = function (string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
          var c = string.charCodeAt(n);
          if (c < 128) {
            utftext += String.fromCharCode(c);
          } else if ((c > 127) && (c < 2048)) {
            utftext += String.fromCharCode((c >> 6) | 192);
            utftext += String.fromCharCode((c & 63) | 128);
          } else {
            utftext += String.fromCharCode((c >> 12) | 224);
            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
            utftext += String.fromCharCode((c & 63) | 128);
          }

        }
        return utftext;
      }

      // private method for UTF-8 decoding
      _utf8_decode = function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
        while (i < utftext.length) {
          c = utftext.charCodeAt(i);
          if (c < 128) {
            string += String.fromCharCode(c);
            i++;
          } else if ((c > 191) && (c < 224)) {
            c2 = utftext.charCodeAt(i + 1);
            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
          } else {
            c2 = utftext.charCodeAt(i + 1);
            c3 = utftext.charCodeAt(i + 2);
            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3
                & 63));
            i += 3;
          }
        }
        return string;
      }
    }

    //yyyy-MM-DD HH-mm-ss
    function strToDate(str) {
      var tempStrs = str.split(" ");
      var dateStrs = tempStrs[0].split("-");
      var year = parseInt(dateStrs[0], 10);
      var month = parseInt(dateStrs[1], 10) - 1;
      var day = parseInt(dateStrs[2], 10);
      if (tempStrs.length > 1) {
        var timeStrs = tempStrs[1].split("-");
        var hour = parseInt(timeStrs [0], 10);
        var minute = parseInt(timeStrs[1], 10) - 1;
        var second = parseInt(timeStrs[2], 10);
        return new Date(year, month, day, hour, minute, second);
      }

      return new Date(year, month, day);
    }

    function isNumber(c) {
      if (c >= '0' && c <= '9') {
        return 1;
      }
      return 0;
    }

    //return 1: address  --- 20Bytes HexString
    //return 2: blockNumber ------ Decimal number
    //return 3: assetName ------ String
    //return other: error
    function getStringType(str) {
      if (null == str) {
        return -1;
      }

      if (typeof(str) != 'string') {
        return -1;
      }

      if (str.length == 0 || str == "") {
        return -1;
      }

      var i = 0;
      if (str.length == 35) {
        if (validAddress(str)) {
          return 1;
        }
      }

      for (i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (!isNumber(c)) {
          break;
        }
      }
      if (i == str.length) {
        return 2;  //Alll Decimal number, BlockNumber
      }

      for (i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (c > ' ') {
          return 3;   //At least one visible character
        }
      }

      return -1;
    }

    /*
     A JavaScript implementation of the SHA family of hashes, as
     defined in FIPS PUB 180-4 and FIPS PUB 202, as well as the corresponding
     HMAC implementation as defined in FIPS PUB 198a

     Copyright Brian Turek 2008-2017
     Distributed under the BSD License
     See http://caligatio.github.com/jsSHA/ for more information

     Several functions taken from Paul Johnston
    */
    'use strict';
    (function (I) {
      function w(c, a, d) {
        var l = 0, b = [], g = 0, f, n, k, e, h, q, y, p, m = !1, t = [], r = [], u,
            z = !1;
        d = d || {};
        f = d.encoding || "UTF8";
        u = d.numRounds || 1;
        if (u !== parseInt(u, 10) || 1 > u) {
          throw Error(
              "numRounds must a integer >= 1");
        }
        if (0 === c.lastIndexOf("SHA-", 0)) {
          if (q = function (b, a) {
                return A(b, a, c)
              }, y = function (b, a, l, f) {
                var g, e;
                if ("SHA-224" === c || "SHA-256" === c) {
                  g = (a + 65 >>> 9 << 4)
                      + 15, e = 16;
                } else {
                  throw Error(
                      "Unexpected error in SHA-2 implementation");
                }
                for (; b.length <= g;) {
                  b.push(0);
                }
                b[a >>> 5] |= 128 << 24 - a % 32;
                a = a + l;
                b[g] = a & 4294967295;
                b[g - 1] = a / 4294967296 | 0;
                l = b.length;
                for (a = 0; a < l; a += e) {
                  f = A(b.slice(a, a + e), f, c);
                }
                if ("SHA-224" === c) {
                  b = [f[0], f[1], f[2], f[3], f[4], f[5],
                    f[6]];
                } else if ("SHA-256" === c) {
                  b = f;
                } else {
                  throw Error(
                      "Unexpected error in SHA-2 implementation");
                }
                return b
              }, p = function (b) {
                return b.slice()
              }, "SHA-224" === c) {
            h = 512, e = 224;
          } else if ("SHA-256"
              === c) {
            h = 512, e = 256;
          } else {
            throw Error(
                "Chosen SHA variant is not supported");
          }
        } else {
          throw Error(
              "Chosen SHA variant is not supported");
        }
        k = B(a, f);
        n = x(c);
        this.setHMACKey = function (b, a, g) {
          var e;
          if (!0 === m) {
            throw Error("HMAC key already set");
          }
          if (!0 === z) {
            throw Error("Cannot set HMAC key after calling update");
          }
          f = (g || {}).encoding || "UTF8";
          a = B(a, f)(b);
          b = a.binLen;
          a = a.value;
          e = h >>> 3;
          g = e / 4 - 1;
          if (e < b / 8) {
            for (a = y(a, b, 0, x(c)); a.length <= g;) {
              a.push(0);
            }
            a[g] &= 4294967040
          } else if (e > b / 8) {
            for (; a.length <= g;) {
              a.push(0);
            }
            a[g] &= 4294967040
          }
          for (b = 0; b <= g; b += 1) {
            t[b] = a[b] ^ 909522486, r[b] = a[b]
                ^ 1549556828;
          }
          n = q(t, n);
          l = h;
          m = !0
        };
        this.update = function (a) {
          var c, f, e, d = 0, p = h >>> 5;
          c = k(a, b, g);
          a = c.binLen;
          f = c.value;
          c = a >>> 5;
          for (e = 0; e < c; e += p) {
            d + h <= a && (n = q(f.slice(e, e + p),
                n), d += h);
          }
          l += d;
          b = f.slice(d >>>
              5);
          g = a % h;
          z = !0
        };
        this.getHash = function (a, f) {
          var d, h, k, q;
          if (!0 === m) {
            throw Error("Cannot call getHash after setting HMAC key");
          }
          k = C(f);
          switch (a) {
            case "HEX":
              d = function (a) {
                return D(a, e, k)
              };
              break;
            case "B64":
              d = function (a) {
                return E(a, e, k)
              };
              break;
            case "BYTES":
              d = function (a) {
                return F(a, e)
              };
              break;
            case "ARRAYBUFFER":
              try {
                h = new ArrayBuffer(0)
              } catch (v) {
                throw Error("ARRAYBUFFER not supported by this environment");
              }
              d = function (a) {
                return G(a, e)
              };
              break;
            default:
              throw Error("format must be HEX, B64, BYTES, or ARRAYBUFFER");
          }
          q = y(b.slice(), g, l, p(n));
          for (h = 1; h < u; h += 1) {
            q = y(q, e, 0, x(c));
          }
          return d(q)
        };
        this.getHMAC = function (a, f) {
          var d, k, t, u;
          if (!1 === m) {
            throw Error(
                "Cannot call getHMAC without first setting HMAC key");
          }
          t = C(f);
          switch (a) {
            case "HEX":
              d = function (a) {
                return D(a, e, t)
              };
              break;
            case "B64":
              d = function (a) {
                return E(a, e, t)
              };
              break;
            case "BYTES":
              d = function (a) {
                return F(a, e)
              };
              break;
            case "ARRAYBUFFER":
              try {
                d = new ArrayBuffer(0)
              } catch (v) {
                throw Error("ARRAYBUFFER not supported by this environment");
              }
              d = function (a) {
                return G(a, e)
              };
              break;
            default:
              throw Error("outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER");
          }
          k = y(b.slice(), g, l, p(n));
          u = q(r, x(c));
          u = y(k, e, h, u);
          return d(u)
        }
      }

      function m() {
      }

      function D(c, a, d) {
        var l = "";
        a /= 8;
        var b, g;
        for (b = 0; b < a; b += 1) {
          g = c[b >>> 2] >>> 8 * (3 + b % 4
              * -1), l += "0123456789abcdef".charAt(g >>> 4 & 15)
              + "0123456789abcdef".charAt(g & 15);
        }
        return d.outputUpper ? l.toUpperCase() : l
      }

      function E(c, a, d) {
        var l = "", b = a / 8, g, f, n;
        for (g = 0; g < b; g += 3) {
          for (f = g + 1 < b ? c[g + 1 >>> 2] : 0, n = g
          + 2 < b ? c[g + 2 >>> 2] : 0, n = (c[g >>> 2] >>> 8 * (3 + g % 4 * -1)
              & 255) << 16 | (f >>> 8 * (3 + (g + 1) % 4 * -1) & 255) << 8 | n >>> 8
              * (3 + (g + 2) % 4 * -1) & 255, f = 0; 4 > f; f += 1) {
            8 * g + 6 * f <= a
                ? l += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(n
                >>>
                6 * (3 - f) & 63) : l += d.b64Pad;
          }
        }
        return l
      }

      function F(c, a) {
        var d = "", l = a / 8, b, g;
        for (b = 0; b < l; b += 1) {
          g = c[b >>> 2] >>> 8 * (3 + b % 4 * -1)
              & 255, d += String.fromCharCode(g);
        }
        return d
      }

      function G(c, a) {
        var d = a / 8, l, b = new ArrayBuffer(d), g;
        g = new Uint8Array(b);
        for (l = 0; l < d; l += 1) {
          g[l] = c[l >>> 2] >>> 8 * (3 + l % 4 * -1) & 255;
        }
        return b
      }

      function C(c) {
        var a = {outputUpper: !1, b64Pad: "=", shakeLen: -1};
        c = c || {};
        a.outputUpper = c.outputUpper || !1;
        !0 === c.hasOwnProperty("b64Pad") && (a.b64Pad = c.b64Pad);
        if ("boolean" !== typeof a.outputUpper) {
          throw Error(
              "Invalid outputUpper formatting option");
        }
        if ("string" !== typeof a.b64Pad) {
          throw Error(
              "Invalid b64Pad formatting option");
        }
        return a
      }

      function B(c, a) {
        var d;
        switch (a) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (c) {
          case "HEX":
            d = function (a, b, c) {
              var f = a.length, d, k, e, h, q;
              if (0 !== f % 2) {
                throw Error(
                    "String of HEX type must be in byte increments");
              }
              b = b || [0];
              c = c || 0;
              q = c >>> 3;
              for (d = 0; d < f; d += 2) {
                k = parseInt(a.substr(d, 2), 16);
                if (isNaN(k)) {
                  throw Error(
                      "String of HEX type contains invalid characters");
                }
                h = (d >>> 1) + q;
                for (e = h >>> 2; b.length <= e;) {
                  b.push(0);
                }
                b[e] |= k << 8 * (3 + h % 4 * -1)
              }
              return {value: b, binLen: 4 * f + c}
            };
            break;
          case "TEXT":
            d = function (c, b, d) {
              var f, n, k = 0, e, h, q, m, p, r;
              b = b || [0];
              d = d || 0;
              q = d >>> 3;
              if ("UTF8" === a) {
                for (r = 3, e = 0; e < c.length;
                    e += 1) {
                  for (f = c.charCodeAt(e), n = [], 128 > f ? n.push(f)
                      : 2048 > f ? (n.push(192 | f >>> 6), n.push(128 | f & 63))
                          : 55296 > f || 57344 <= f ? n.push(224 | f >>> 12, 128 | f
                              >>> 6 & 63, 128 | f & 63) : (e += 1, f = 65536 + ((f
                              & 1023) << 10 | c.charCodeAt(e) & 1023), n.push(240
                              | f
                              >>> 18, 128 | f >>> 12 & 63, 128 | f >>> 6 & 63, 128
                              | f
                              & 63)), h = 0; h < n.length; h += 1) {
                    p = k +
                        q;
                    for (m = p >>> 2; b.length <= m;) {
                      b.push(0);
                    }
                    b[m] |= n[h] << 8 * (r + p % 4 * -1);
                    k += 1
                  }
                }
              } else if ("UTF16BE" === a || "UTF16LE"
                  === a) {
                for (r = 2, n = "UTF16LE" === a && !0 || "UTF16LE" !== a
                    && !1, e = 0; e < c.length; e += 1) {
                  f = c.charCodeAt(e);
                  !0 === n && (h = f & 255, f = h << 8 | f >>> 8);
                  p = k + q;
                  for (m = p >>> 2; b.length <= m;) {
                    b.push(0);
                  }
                  b[m] |= f << 8 * (r + p % 4 * -1);
                  k += 2
                }
              }
              return {value: b, binLen: 8 * k + d}
            };
            break;
          case "B64":
            d = function (a, b, c) {
              var f = 0, d, k, e, h, q, m, p;
              if (-1 === a.search(/^[a-zA-Z0-9=+\/]+$/)) {
                throw Error(
                    "Invalid character in base-64 string");
              }
              k = a.indexOf("=");
              a = a.replace(/\=/g,
                  "");
              if (-1 !== k && k < a.length) {
                throw Error(
                    "Invalid '=' found in base-64 string");
              }
              b = b || [0];
              c = c || 0;
              m = c >>> 3;
              for (k = 0; k < a.length; k += 4) {
                q = a.substr(k, 4);
                for (e = h = 0; e < q.length;
                    e += 1) {
                  d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(
                      q[e]), h |= d << 18 - 6 * e;
                }
                for (e = 0; e < q.length - 1; e += 1) {
                  p = f + m;
                  for (d = p >>> 2; b.length <= d;) {
                    b.push(0);
                  }
                  b[d] |= (h >>> 16 - 8 * e & 255) << 8 * (3 + p % 4 * -1);
                  f += 1
                }
              }
              return {value: b, binLen: 8 * f + c}
            };
            break;
          case "BYTES":
            d = function (a, b, c) {
              var d, n, k, e, h;
              b = b || [0];
              c = c || 0;
              k = c >>> 3;
              for (n = 0; n < a.length; n +=
                  1) {
                d = a.charCodeAt(n), h = n + k, e = h >>> 2, b.length <= e
                && b.push(0), b[e] |= d << 8 * (3 + h % 4 * -1);
              }
              return {value: b, binLen: 8 * a.length + c}
            };
            break;
          case "ARRAYBUFFER":
            try {
              d = new ArrayBuffer(0)
            } catch (l) {
              throw Error("ARRAYBUFFER not supported by this environment");
            }
            d = function (a, b, c) {
              var d, n, k, e, h;
              b = b || [0];
              c = c || 0;
              n = c >>> 3;
              h = new Uint8Array(a);
              for (d = 0; d < a.byteLength; d += 1) {
                e = d + n, k = e >>> 2, b.length
                <= k && b.push(0), b[k] |= h[d] << 8 * (3 + e % 4 * -1);
              }
              return {value: b, binLen: 8 * a.byteLength + c}
            };
            break;
          default:
            throw Error("format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER");
        }
        return d
      }

      function r(c, a) {
        return c >>> a | c << 32 - a
      }

      function J(c, a, d) {
        return c & a ^ ~c & d
      }

      function K(c, a, d) {
        return c & a ^ c & d ^ a & d
      }

      function L(c) {
        return r(c, 2) ^ r(c, 13) ^ r(c, 22)
      }

      function M(c) {
        return r(c, 6) ^ r(c, 11) ^ r(c, 25)
      }

      function N(c) {
        return r(c, 7) ^ r(c, 18) ^ c >>> 3
      }

      function O(c) {
        return r(c, 17) ^ r(c, 19) ^ c >>> 10
      }

      function P(c, a) {
        var d = (c & 65535) + (a & 65535);
        return ((c >>> 16) + (a >>> 16) + (d >>> 16) & 65535) << 16 | d & 65535
      }

      function Q(c, a, d, l) {
        var b = (c & 65535) + (a & 65535) + (d & 65535) + (l & 65535);
        return ((c >>> 16) + (a >>> 16) + (d >>> 16) + (l >>> 16) + (b >>>
            16) & 65535) << 16 | b & 65535
      }

      function R(c, a, d, l, b) {
        var g = (c & 65535) + (a & 65535) + (d & 65535) + (l & 65535) + (b & 65535);
        return ((c >>> 16) + (a >>> 16) + (d >>> 16) + (l >>> 16) + (b >>> 16) + (g
            >>> 16) & 65535) << 16 | g & 65535
      }

      function x(c) {
        var a = [], d;
        if (0 === c.lastIndexOf("SHA-", 0)) {
          switch (a = [3238371032, 914150663,
            812702999, 4144912697, 4290775857, 1750603025, 1694076839,
            3204075428], d = [1779033703, 3144134277, 1013904242, 2773480762,
            1359893119, 2600822924, 528734635, 1541459225], c) {
            case "SHA-224":
              break;
            case "SHA-256":
              a = d;
              break;
            case "SHA-384":
              a = [new m, new m,
                new m, new m, new m, new m, new m, new m];
              break;
            case "SHA-512":
              a = [new m, new m, new m, new m, new m, new m, new m, new m];
              break;
            default:
              throw Error("Unknown SHA variant");
          }
        } else {
          throw Error("No SHA variants supported");
        }
        return a
      }

      function A(c, a, d) {
        var l, b, g, f, n, k, e, h, m, r, p, w, t, x, u, z, A, B, C, D, E, F,
            v = [], G;
        if ("SHA-224" === d || "SHA-256"
            === d) {
          r = 64, w = 1, F = Number, t = P, x = Q, u = R, z = N, A = O, B = L, C = M, E = K, D = J, G = H;
        } else {
          throw Error(
              "Unexpected error in SHA-2 implementation");
        }
        d = a[0];
        l = a[1];
        b = a[2];
        g = a[3];
        f = a[4];
        n = a[5];
        k = a[6];
        e = a[7];
        for (p =
            0; p < r; p += 1) {
          16 > p ? (m = p * w, h = c.length <= m ? 0
              : c[m], m = c.length <= m + 1 ? 0 : c[m + 1], v[p] = new F(h, m))
              : v[p] = x(A(v[p - 2]), v[p - 7], z(v[p - 15]), v[p - 16]), h = u(e,
              C(f), D(f, n, k), G[p], v[p]), m = t(B(d),
              E(d, l, b)), e = k, k = n, n = f, f = t(g,
              h), g = b, b = l, l = d, d = t(h, m);
        }
        a[0] = t(d, a[0]);
        a[1] = t(l, a[1]);
        a[2] = t(b, a[2]);
        a[3] = t(g, a[3]);
        a[4] = t(f, a[4]);
        a[5] = t(n, a[5]);
        a[6] = t(k, a[6]);
        a[7] = t(e, a[7]);
        return a
      }

      var H;
      H = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206,
        2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
        2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051,
        2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616,
        659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
        2756734187, 3204031479, 3329325298];
      "function" === typeof define && define.amd ? define(function () {
        return w
      }) : "undefined" !== typeof exports ? ("undefined" !== typeof module
      && module.exports && (module.exports = w), exports = w) : I.jsSHA = w
    })(this);

    function SHA256(msgBytes) {
      var shaObj = new jsSHA("SHA-256", "HEX");
      var msgHex = byteArray2hexStr(msgBytes);
      shaObj.update(msgHex);
      var hashHex = shaObj.getHash("HEX");
      var hashBytes = hexStr2byteArray(hashHex);
      return hashBytes;
    }

    //return address by Base58Check String,
    function getBase58CheckAddress(addressBytes) {
      var hash0 = SHA256(addressBytes);
      var hash1 = SHA256(hash0);
      var checkSum = hash1.slice(0, 4);
      checkSum = addressBytes.concat(checkSum);
      var base58Check = encode58(checkSum);

      return base58Check;
    }

    this.decodeToHexString = function (input) {
      var bytes = base64DecodeFromString(input);
      var HexString = byte2hexStr(bytes);
      return HexString;
    }

    this.decodeToString = function (input) {
      console.log("input:" + input);
      var bytes = base64DecodeFromString(input);
      //console.log("bytes:" + bytes);
      var String = bytesToString(bytes);
      //console.log("String:" + String);
      return String;
    }

    this.base64ToBase58Check = function (input) {
      var bytes = base64DecodeFromString(input);
      var base58check = getBase58CheckAddress(bytes);
      return base58check;
    }

    window.onload = function (ev) {
      var ipvalue = localStorage.getItem('ip');  // 存储数据
      document.getElementById("ip").value = ipvalue
    }
    var result;
    convert = function (input) {
      if (input !== null) {
        for (var key in input) {
          var value = input[key];
          if (typeof value == "object") {
            convert(value);
          } else {
            switch (key) {
              case "account_name":
              case "host":
              case "description":
                //case "url":
                input[key] = decodeToString(input[key]);
                break;
              case "parentHash":
              case "witness_signature":
              case "txTrieRoot":
                input[key] = decodeToHexString(input[key]);
                break;
              case "witness_address":
              case "owner_address":
              case "to_address":
              case "vote_address":
              case "address":

                input[key] = base64ToBase58Check(input[key]);
                break;
              default:
                break;
            }
          }
        }
      }
    };

    function listaccounts() {
      localStorage.setItem('ip', document.getElementById("ip").value);  // 存储数据
      var requestaddress = "http://" + document.getElementById("ip").value
          + "/wallet/listaccounts";
      axios.get(requestaddress)
      .then(function (response) {
            convert(response.data);
            result = JSON.stringify(response.data);
            document.documentElement.innerHTML = result;
          }
      )
      .catch(function (error) {
        console.log(error);
      });
    }

    function listwitnesses() {
      var requestaddress = "http://" + document.getElementById("ip").value
          + "/wallet/listwitnesses";
      axios.get(requestaddress)
      .then(function (response) {
            convert(response.data);
            result = JSON.stringify(response.data);
            document.documentElement.innerHTML = result;
          }
      )
      .catch(function (error) {
        console.log(error);
      });
    }

    function listnodes() {
      var requestaddress = "http://" + document.getElementById("ip").value
          + "/wallet/listnodes";
      axios.get(requestaddress)
      .then(function (response) {
            convert(response.data);
            result = JSON.stringify(response.data);
            document.documentElement.innerHTML = result;
          }
      )
      .catch(function (error) {
        console.log(error);
      });
    }

    function getassetissuelist() {
      var requestaddress = "http://" + document.getElementById("ip").value
          + "/wallet/getassetissuelist";
      axios.get(requestaddress)
      .then(function (response) {
            convert(response.data);
            result = JSON.stringify(response.data);
            document.documentElement.innerHTML = result;
          }
      )
      .catch(function (error) {
        console.log(error);
      });
    }

    function getnowblock() {
      var requestaddress = "http://" + document.getElementById("ip").value
          + "/wallet/getnowblock";
      axios.get(requestaddress)
      .then(function (response) {
            convert(response.data);
            result = JSON.stringify(response.data);
            document.documentElement.innerHTML = result;
          }
      )
      .catch(function (error) {
        console.log(error);
      });
    }

    function totaltransaction() {
      var requestaddress = "http://" + document.getElementById("ip").value
          + "/wallet/totaltransaction";
      axios.get(requestaddress)
      .then(function (response) {
            convert(response.data);
            result = JSON.stringify(response.data);
            document.documentElement.innerHTML = result;
          }
      )
      .catch(function (error) {
        console.log(error);
      });
    }

    function getBlockBynum() {
      var requestaddress = "http://" + document.getElementById("ip").value
          + "/wallet/getblockbynum?num=" + document.getElementById("blcoknum").value;
      axios.get(requestaddress)
      .then(function (response) {
            convert(response.data);
            result = JSON.stringify(response.data);
            document.documentElement.innerHTML = result;
          }
      )
      .catch(function (error) {
        console.log(error);
      });
    }
  </script>

</head>

<body>
<br/>输入IP：
<input id="ip" type="text" autocomplete="on">
<br/>

<br/>查看accounts：
<button onclick="listaccounts()">listaccounts</button>
<br/>查看witness：
<button onclick="listwitnesses()">listwitnesses</button>

<br/>查看nodes：
<button onclick="listnodes()">listnodes</button>
<br/>查看资产列表：
<button onclick="getassetissuelist()">getassetissuelist</button>
<br/>查看当前块：
<button onclick="getnowblock()">getnowblock</button>
<br/>查看全部交易：
<button onclick="totaltransaction()">totaltransaction</button>
<br/>
根据块号查询Block：
<input id="blcoknum" type="text" autocomplete="on">
<button onclick="getBlockBynum()">getBlockBynum</button>
</body>
</html>